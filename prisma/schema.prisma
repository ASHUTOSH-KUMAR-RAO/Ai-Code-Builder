// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}


//! Aur maje ki Baat btau prisma hamesa decorator use krta hai ,pta hai kis liye kyuki isese hi ye define krta hai primary key and whatever jo bhi hum prisma ke andar use krte hai,jaise hamne yeha  per @ use kiya hai to isko hi hum decorator bolte





//? Aur jaise hum  django ke andar apne db mein kuch changes krte hai uske migration ke liye command run krte hai same prisma mein bhi hum migration command run krte hai then ek generated folder create hota ha jiske andar migration changes hote hai,(aur ek maje ki baat btau jaab bhi hum 'npm prisma migrate dev', command run krte hai n to internally ('npx prisma generate',command run hota hai aur jaise hi, ye command run krte hai to bahut types create krta hai prisma ke andar to socho ek command se kitna magic hota hai 🤷‍♀️)) ,and prisma offcial docs https://www.prisma.io/docs/guides

// todo => This creates two models: User and Post, with a one-to-many relationship between them.


//* Databse Reset ke need humko sirf development level per hi padti hai production per nhi padti hai

enum MessageRole{
  USER
  ASSISTANT
}

enum MessageType{
  RESULT
  ERROR
}

// ! enum basically ek aisa type hota hai jisme hum kuch predefined values rkhte hai jise hum baar-baar use kr skte hai jaise ki yaha per humne MessageRole enum banaya hai jisme do values hai USER and ASSISTANT to ab hum is enum ko apne model ke andar use kr skte hai jaise ki niche Message model ke andar use kiya hai

model Project{
  id String @id @default(uuid())
  name String
  userId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  messages Message[] //one to many relationship with Message model that means ek project ke andar kai sare messages ho skte hai

}
model Message {
  id        String                                                 @id @default(uuid())
  content   String
  role      MessageRole
  type      MessageType
  createdAt DateTime                            @default(now())
  updatedAt DateTime  @updatedAt  // jaise yeha per humne @updatedAt @updatedAt use kiya hai to ye field automatically update ho jayega jab bhi record update hoga , aur isko hi hum decorator bolte hai

  fragments Fragment? //one to one relationship with Fragment model (optional) that means ek message ke saath ek hi fragment ho skta hai and fragment optional hai

  projectId String
  project   Project @relation(fields: [projectId], references: [id],onDelete: Cascade) // cascade means ki jab project delete hoga to uske saath saath uske messages bhi delete ho jayenge,cascade is a referential action that means when a referenced record is deleted, all associated records in the related table will also be automatically deleted
}


model Fragment {
  id String @id @default(uuid())
  messageId String @unique
  message Message @relation(fields: [messageId], references: [id],onDelete: Cascade) // cascade means ki jab message delete hoga to uske saath saath uske fragments bhi delete ho jayenge,cascade is a referential action that means when a referenced record is deleted, all associated records in the related table will also be automatically deleted

  sandboxUrl String
  title String
  files Json

  createdAt DateTime                @default(now())
  updatedAt DateTime    @updatedAt
}
